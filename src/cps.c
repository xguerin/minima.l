#include <mnml/cps.h>
#include <mnml/debug.h>
#include <mnml/lisp.h>
#include <mnml/slab.h>
#include <mnml/utils.h>

/*
 * Utility functions.
 */

static atom_t
cps_make_placeholder(const size_t counter) {
  char buffer[LISP_SYMBOL_LENGTH];
  int len = snprintf(buffer, LISP_SYMBOL_LENGTH, "_%ld", counter);
  MAKE_SYMBOL_STATIC(sym, buffer, len);
  return lisp_make_symbol(sym);
}

/*
 * Recursively swap funcall with placeholders.
 */

static atom_t
cps_swap(const atom_t cell, size_t* counter, atom_t* spill)
{
  TRACE_SEXP(cell);
  /*
   * If it's NIL, return.
   */
  if (IS_NULL(cell)) {
    return cell;
  }
  /*
   * Grab CAR and CDR.
   */
  atom_t car = lisp_car(cell);
  atom_t cdr = lisp_cdr(cell);
  X(cell);
  /*
   * Call swap recursively.
   */
  atom_t curswap = cps_swap(cdr, counter, spill);
  /*
   * If CAR is not a list, just CONS and return.
   */
  if (!IS_PAIR(car)) {
    atom_t result = lisp_cons(car, curswap);
    X(car); X(curswap);
    return result;
  }
  /*
   * Generate a symbol for the placeholder and increment the counter.
   */
  atom_t sym_n = cps_make_placeholder(*counter);
  *counter += 1;
  /*
   * Call swap on the argument.
   */
  atom_t recspill = UP(NIL);
  atom_t recswap = cps_swap(car, counter, &recspill);
  /*
   * CONS the result of the swap into the spill.
   */
  atom_t spill0 = *spill;
  atom_t spill1 = lisp_cons(recswap, spill0);
  X(recswap); X(spill0);
  *spill = lisp_conc(recspill, spill1);
  X(recspill); X(spill1);
  /*
   * Append the symbol and return.
   */
  atom_t result = lisp_cons(sym_n, curswap);
  X(sym_n); X(curswap);
  return result;
}

/*
 * Recursively decorate funcalls with lambdas.
 */

static atom_t
cps_wrap(const atom_t cell, const size_t padding, size_t* counter)
{
  TRACE_SEXP(cell);
  /*
   * If it's NIL, return.
   */
  if (IS_NULL(cell)) {
    atom_t sym_k = cps_make_placeholder(*counter);
    atom_t result = lisp_cons(sym_k, cell);
    X(sym_k); X(cell);
    *counter = padding;
    return result;
  }
  /*
   * Grab CAR and CDR.
   */
  atom_t car = lisp_car(cell);
  atom_t cdr = lisp_cdr(cell);
  X(cell);
  /*
   * Call swap recursively.
   */
  atom_t curwrap = cps_wrap(cdr, padding, counter);
  /*
   * Generate a symbol for the placeholder and increment the counter.
   */
  atom_t sym_n = cps_make_placeholder(*counter);
  *counter += 1;
  /*
   * Create the arglist.
   */
  atom_t tmp = lisp_cons(sym_n, NIL);
  atom_t arg = lisp_cons(tmp, NIL);
  X(sym_n); X(tmp);
  /*
   * Append the arglist to the funcall.
   */
  atom_t cn0 = lisp_append(arg, car);
  /*
   * Create the lambda call.
   */
  MAKE_SYMBOL_STATIC(sym_l, "\\", 1);
  atom_t lbd = lisp_make_symbol(sym_l);
  atom_t fun = lisp_cons(lbd, cn0);
  X(lbd); X(cn0);
  /*
   * Construct the result.
   */
  atom_t res = lisp_cons(fun, curwrap);
  X(fun); X(curwrap);
  return res;
}

/*
 * Convert a funcall body in direct style into a list of lambdas.
 * Each lambda at index N uses the lambda at index N + 1 as a continuation.
 */

atom_t
lisp_cps_convert(const atom_t cell, const size_t padding)
{
  size_t cnt = padding;
  atom_t spl = UP(NIL);
  atom_t acc = cps_swap(cell, &cnt, &spl);
  atom_t fns = lisp_append(spl, acc);
  return cps_wrap(fns, padding, &cnt);
}

/*
 * Combine lambdas generated by lisp_cps_convert together.
 */

atom_t
lisp_cps_bind(const atom_t cell)
{
  TRACE_SEXP(cell);
  /*
   * If it's NIL, return.
   */
  if (IS_NULL(cell)) {
    return cell;
  }
  /*
   * Grab CAR and CDR.
   */
  atom_t car = lisp_car(cell);
  atom_t cdr = lisp_cdr(cell);
  X(cell);
  /*
   * Call bind recursively.
   */
  atom_t cur = lisp_cps_bind(cdr);
  /*
   * If cur is NIL, just cons with CAR.
   */
  if (IS_NULL(cur)) {
    return car;
  }
  /*
   * Split the lambda and append cur to the body.
   */
  SPLIT_LAMBDA(car, symb, larg, lbdy);
  atom_t next = lisp_append(lbdy, cur);
  /*
   * And rebuild the lambda.
   */
  MAKE_LAMBDA(result, symb, larg, next);
  return result;
}
