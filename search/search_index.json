{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Minima.l Opinionated LISP dialect that takes some of its inspirations from Picolisp , CHICKEN Scheme , and other great languages. The source code is located here . Example (load '(math + - <=) '(io prinl) '(std if)) (def fib (N) (if (<= N 1) N (+ (fib (- N 1)) (fib (- N 2))))) (prinl \"Result: \" (fib 30)) License Copyright (c) 2020 Xavier R. Gu\u00e9rin <copyright@applepine.org> Permission to use, copy, modify, and distribute this software for any purpose with or without fee is hereby granted, provided that the above copyright notice and this permission notice appear in all copies. THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.","title":"Home"},{"location":"#minimal","text":"Opinionated LISP dialect that takes some of its inspirations from Picolisp , CHICKEN Scheme , and other great languages. The source code is located here .","title":"Minima.l"},{"location":"#example","text":"(load '(math + - <=) '(io prinl) '(std if)) (def fib (N) (if (<= N 1) N (+ (fib (- N 1)) (fib (- N 2))))) (prinl \"Result: \" (fib 30))","title":"Example"},{"location":"#license","text":"Copyright (c) 2020 Xavier R. Gu\u00e9rin <copyright@applepine.org> Permission to use, copy, modify, and distribute this software for any purpose with or without fee is hereby granted, provided that the above copyright notice and this permission notice appear in all copies. THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.","title":"License"},{"location":"manual/Interpreter/","text":"Interpreter The intepreter is called mnml . It can be run interactively: $ mnml > It accepts a file name as a parameter: $ mnml file.l It can be used as a shebang interpreter: #!/usr/bin/env mnml (load '(math +)) (+ 1 2) By default, only the symbols def , load , and quote from the std module are available. Scripts are strongly encouraged to load what they use. Environment variables MNML_DEBUG If Minima.l has been compiled with debug support, this variable controls which class of debug output to generate. It accepts a comma-separated list of category names: BIND : argument binding operations CHAN : I/O channel operations CLOS : evaluation closures CONS : list construction operations EVAL : expression evaluation MAKE : atom creation operations * MODL : module operations REFC : reference counting operations SLOT : slot allocator operations SLAB : slab allocator operations $ MNML_DEBUG=MODL,SLOT mnml The variable can be left empty to restrict debug output to eval . MNML_MODULE_PATH This variable controls where to look for modules, the default being the lib/mnml directory in the installation prefix. It accepts a colon-separated list of paths: $ MNML_MODULE_PATH=/some/path:/some/other/path mnml MNML_SCRIPT_PATH This variable controls where to look for lisp scripts, the default being share/mnml in the installation prefix. It accepts a colon-separated list of paths: $ MNML_SCRIPT_PATH=/some/path:/some/other/path mnml When set, that path is used to match occurences of @lib in (load) statements.","title":"Interpreter"},{"location":"manual/Interpreter/#interpreter","text":"The intepreter is called mnml . It can be run interactively: $ mnml > It accepts a file name as a parameter: $ mnml file.l It can be used as a shebang interpreter: #!/usr/bin/env mnml (load '(math +)) (+ 1 2) By default, only the symbols def , load , and quote from the std module are available. Scripts are strongly encouraged to load what they use.","title":"Interpreter"},{"location":"manual/Interpreter/#environment-variables","text":"","title":"Environment variables"},{"location":"manual/Interpreter/#mnml_debug","text":"If Minima.l has been compiled with debug support, this variable controls which class of debug output to generate. It accepts a comma-separated list of category names: BIND : argument binding operations CHAN : I/O channel operations CLOS : evaluation closures CONS : list construction operations EVAL : expression evaluation MAKE : atom creation operations * MODL : module operations REFC : reference counting operations SLOT : slot allocator operations SLAB : slab allocator operations $ MNML_DEBUG=MODL,SLOT mnml The variable can be left empty to restrict debug output to eval .","title":"MNML_DEBUG"},{"location":"manual/Interpreter/#mnml_module_path","text":"This variable controls where to look for modules, the default being the lib/mnml directory in the installation prefix. It accepts a colon-separated list of paths: $ MNML_MODULE_PATH=/some/path:/some/other/path mnml","title":"MNML_MODULE_PATH"},{"location":"manual/Interpreter/#mnml_script_path","text":"This variable controls where to look for lisp scripts, the default being share/mnml in the installation prefix. It accepts a colon-separated list of paths: $ MNML_SCRIPT_PATH=/some/path:/some/other/path mnml When set, that path is used to match occurences of @lib in (load) statements.","title":"MNML_SCRIPT_PATH"},{"location":"manual/Language/","text":"Language Source encoding The source encoding is UTF-8. Comment # This is a comment Types Table Name Description List ( ... ) Number Positive and negative 64-bit integers Symbol 16-character string Character A ^ -prefixed printable character T Stands for true NIL The empty list, also stands for false _ Wildcard, used as a placeholder during deconstruction Symbols Symbols are bound to values. Undefined symbols are unbound and resolve to NIL . Symbols can be created or altered globally using the def and setq functions. Symbols can also be defined locally using the let function. Strings The grammar supports the string type. Represented as a \" -delimited string of characters, it is internally stored as a list of characters. For example: : \"hello\" > (^h ^e ^l ^l ^o) Expression evaluation Generic rules Numbers, strings, NIL , T , and _ evaluate to themselves Symbols are dereferenced to their bound values Lists are evaluated as expressions Expressions Expression take the following form: (FUNCTION ARGS ...) . The FUNCTION can be: A symbol that must resolve to a function definition A quoted function definition A lambda definition The forms 1, 2, and 3 are mutually interchangeable: : (def add (a b) (+ a b)) > ((a b) NIL (+ a b)) : (add 1 2) # Form 1 > 3 : ('((a b) NIL (+ a b)) 1 2) # Form 2 > 3 : ((\\ (a b) (+ a b)) 1 2) # Form 3 > 3 Functions Functions are represented internally as the following 3-uple: (ARGUMENTS CLOSURE . BODY) The ARGUMENTS element is a list of symbols representing the arguments of the functions. The CLOSURE element is an association list that contains the context of the function at the definition site. Lastly, the BODY element is the expression of the function. When defined through plugins, the body may also be a number representing the memory address of the native implementation of the function. Bindings The BINDINGS list may be one of these form: NIL or () : the function takes no argument SYMBOL : the unevaluated list of arguments is associated with SYMBOL LIST : arguments are evaluated and assigned to the symbols in LIST Lambdas Lambda functions are defined using the \\ keyword. Invocation of \\ is similar to def : : ((\\ (x y) (+ x y)) 1 1) > 2 : ((\\ (x) (map (\\ (n) (+ n 1)) x)) '(1 2 3 4)) > (2 3 4 5) The closure available at the time a lambda is defined is placed in its signature. This is the lambda's define-site closure . When the lambda is called, its closure is extended with the environment available where the call is performed. This is the lambda's call-site closure . Currying Minima.l supports currying. It uses the function's closure to store the curried arguments. Curryring is available to all lisp and native functions. For example: : (def add (a b) (+ a b)) > ((a b) NIL (+ a b)) : (setq +1 (add 1)) > ((b) ((a . 1)) (+ a b)) : (+1 2) > 3 Recursion A function defined using def can be recursive. When functions are defined, symbols with their names are not resolved in their closure and are resolved dynamically in the symbol domain instead. A lambda defined using let can also be recursive. Similarly as above, the recursive calls are resolved dynamically. However, the resolution process first looks into the define-site closure of the lambda, then its call-site closure , and finally in the symbol domain. There is a caveat however: since the function symbols are resolved dynamically, redefining these symbols will lead to undefined behavior. For instance, the following is a valid recursive lambda and returns 0 : (let ((fn . (\\ (A) (if (= A 0) 0 (fn (- A 1)))))) (fn 10)) However, the following is not and returns 10 : (let ((fn . (\\ (A) (+ A 1)))) (let ((fn . (\\ (A) (unless (= A 0) (fn (- A 1)))))) (fn 10))) Tail-call optimization When functions are defined with def or \\ in let , the function's body is scanned for potential tail calls. During evaluation, when a tail call is encountered, its argument are evaluated at its call-site and returned to the parent. These arguments are then used at the root of the function in a new application of that function, executed in a tight loop. Value deconstruction Assignation of arguments in def , lamda , or let functions support deconstruction. For instance, with def : : (def sum3 ((a b c)) (+ (+ a b) c)) > sum3 : (sum3 (list 1 2 3)) > 6 Or with a lambda: : (setq data '((\"hello\" . 1) (\"world\" . 2))) > ((\"hello\" . 1) (\"world\" . 2)) : (foldl (\\ (acc (_ . v))(+ acc v)) 0 data) > 3 Global variables ARGV When mnml is executed as a #! interpreter, the ARGV global contains the argument vector of the script. CONFIG The CONFIG global contains the current runtime of the interpreter. It contains the installation PREFIX , the interpreter VERSION , its build timestamp BUILD_TS , and the name COMPNAME and version COMPVER of the compiler used to build it. ENV The ENV global contains the environment at the time of the invocation of the interpreter.","title":"Language"},{"location":"manual/Language/#language","text":"","title":"Language"},{"location":"manual/Language/#source-encoding","text":"The source encoding is UTF-8.","title":"Source encoding"},{"location":"manual/Language/#comment","text":"# This is a comment","title":"Comment"},{"location":"manual/Language/#types","text":"","title":"Types"},{"location":"manual/Language/#table","text":"Name Description List ( ... ) Number Positive and negative 64-bit integers Symbol 16-character string Character A ^ -prefixed printable character T Stands for true NIL The empty list, also stands for false _ Wildcard, used as a placeholder during deconstruction","title":"Table"},{"location":"manual/Language/#symbols","text":"Symbols are bound to values. Undefined symbols are unbound and resolve to NIL . Symbols can be created or altered globally using the def and setq functions. Symbols can also be defined locally using the let function.","title":"Symbols"},{"location":"manual/Language/#strings","text":"The grammar supports the string type. Represented as a \" -delimited string of characters, it is internally stored as a list of characters. For example: : \"hello\" > (^h ^e ^l ^l ^o)","title":"Strings"},{"location":"manual/Language/#expression-evaluation","text":"","title":"Expression evaluation"},{"location":"manual/Language/#generic-rules","text":"Numbers, strings, NIL , T , and _ evaluate to themselves Symbols are dereferenced to their bound values Lists are evaluated as expressions","title":"Generic rules"},{"location":"manual/Language/#expressions","text":"Expression take the following form: (FUNCTION ARGS ...) . The FUNCTION can be: A symbol that must resolve to a function definition A quoted function definition A lambda definition The forms 1, 2, and 3 are mutually interchangeable: : (def add (a b) (+ a b)) > ((a b) NIL (+ a b)) : (add 1 2) # Form 1 > 3 : ('((a b) NIL (+ a b)) 1 2) # Form 2 > 3 : ((\\ (a b) (+ a b)) 1 2) # Form 3 > 3","title":"Expressions"},{"location":"manual/Language/#functions","text":"Functions are represented internally as the following 3-uple: (ARGUMENTS CLOSURE . BODY) The ARGUMENTS element is a list of symbols representing the arguments of the functions. The CLOSURE element is an association list that contains the context of the function at the definition site. Lastly, the BODY element is the expression of the function. When defined through plugins, the body may also be a number representing the memory address of the native implementation of the function.","title":"Functions"},{"location":"manual/Language/#bindings","text":"The BINDINGS list may be one of these form: NIL or () : the function takes no argument SYMBOL : the unevaluated list of arguments is associated with SYMBOL LIST : arguments are evaluated and assigned to the symbols in LIST","title":"Bindings"},{"location":"manual/Language/#lambdas","text":"Lambda functions are defined using the \\ keyword. Invocation of \\ is similar to def : : ((\\ (x y) (+ x y)) 1 1) > 2 : ((\\ (x) (map (\\ (n) (+ n 1)) x)) '(1 2 3 4)) > (2 3 4 5) The closure available at the time a lambda is defined is placed in its signature. This is the lambda's define-site closure . When the lambda is called, its closure is extended with the environment available where the call is performed. This is the lambda's call-site closure .","title":"Lambdas"},{"location":"manual/Language/#currying","text":"Minima.l supports currying. It uses the function's closure to store the curried arguments. Curryring is available to all lisp and native functions. For example: : (def add (a b) (+ a b)) > ((a b) NIL (+ a b)) : (setq +1 (add 1)) > ((b) ((a . 1)) (+ a b)) : (+1 2) > 3","title":"Currying"},{"location":"manual/Language/#recursion","text":"A function defined using def can be recursive. When functions are defined, symbols with their names are not resolved in their closure and are resolved dynamically in the symbol domain instead. A lambda defined using let can also be recursive. Similarly as above, the recursive calls are resolved dynamically. However, the resolution process first looks into the define-site closure of the lambda, then its call-site closure , and finally in the symbol domain. There is a caveat however: since the function symbols are resolved dynamically, redefining these symbols will lead to undefined behavior. For instance, the following is a valid recursive lambda and returns 0 : (let ((fn . (\\ (A) (if (= A 0) 0 (fn (- A 1)))))) (fn 10)) However, the following is not and returns 10 : (let ((fn . (\\ (A) (+ A 1)))) (let ((fn . (\\ (A) (unless (= A 0) (fn (- A 1)))))) (fn 10)))","title":"Recursion"},{"location":"manual/Language/#tail-call-optimization","text":"When functions are defined with def or \\ in let , the function's body is scanned for potential tail calls. During evaluation, when a tail call is encountered, its argument are evaluated at its call-site and returned to the parent. These arguments are then used at the root of the function in a new application of that function, executed in a tight loop.","title":"Tail-call optimization"},{"location":"manual/Language/#value-deconstruction","text":"Assignation of arguments in def , lamda , or let functions support deconstruction. For instance, with def : : (def sum3 ((a b c)) (+ (+ a b) c)) > sum3 : (sum3 (list 1 2 3)) > 6 Or with a lambda: : (setq data '((\"hello\" . 1) (\"world\" . 2))) > ((\"hello\" . 1) (\"world\" . 2)) : (foldl (\\ (acc (_ . v))(+ acc v)) 0 data) > 3","title":"Value deconstruction"},{"location":"manual/Language/#global-variables","text":"","title":"Global variables"},{"location":"manual/Language/#argv","text":"When mnml is executed as a #! interpreter, the ARGV global contains the argument vector of the script.","title":"ARGV"},{"location":"manual/Language/#config","text":"The CONFIG global contains the current runtime of the interpreter. It contains the installation PREFIX , the interpreter VERSION , its build timestamp BUILD_TS , and the name COMPNAME and version COMPVER of the compiler used to build it.","title":"CONFIG"},{"location":"manual/Language/#env","text":"The ENV global contains the environment at the time of the invocation of the interpreter.","title":"ENV"},{"location":"manual/Modules/","text":"Modules Modules are collections of function definitions. They are loaded using the load function. They can be implemented in in any language that compiles into shared libraries with a C interface (binary modules). Binary interface A module is a shared library that must export the following interface: const char * lisp_module_name(); atom_t lisp_module_setup(const lisp_t lisp); The lisp_module_setup function returns an atom_t value that points to a list definition as follows: (ARGUMENTS NIL . INTEGER) The integer part represents a pointer to a function with the following signature: atom_t lisp_function_NAME(const lisp_t lisp, const atom_t closure, const atom_t args); Example Let's take the following code written for an add function and save it in a file called add.c : #include <mnml/lisp.h> #include <mnml/module.h> #include <mnml/slab.h> static atom_t lisp_function_add(const lisp_t lisp, const atom_t closure) { LISP_ARGS(closure, C, X, Y); /* * Make sure the arguments are numbers. */ if (!(IS_NUMB(x) && IS_NUMB(y))) { X(x, y); return UP(NIL); } /* * Return the new value. */ atom_t result = lisp_make_number(x->number + y->number); X(x, y); return result; } LISP_MODULE_SETUP(add, add, X, Y, NIL) Then, let's compile it: $ cc -I${PREFIX}/include -L${PREFIX}/lib -lminimal -o libminimal_function_add.${LD_EXT} add.c Where ${PREFIX} is Minima.l's installation prefix and ${LD_EXT} the linker extension for your platform ( .so on most, .dylib on Mac). Finally, place this shared object in your Minima.l cache ( $HOME/.mnml ) and fire the interpreter: : (load 'add) > add : (add 1 2) > 3 Programming interface Atom type The basic type in Minima.l is atom_t . This type represents numbers, characters, symbols, and pairs. Some symbols are defined as singletons, like NIL , TRUE , QUOTE , and WILDCARD . Allocation Atom values are allocated using functions in the maker interface: atom_t lisp_make_char(const char c); atom_t lisp_make_number(const int64_t num); atom_t lisp_make_string(const char * const s, const size_t len); atom_t lisp_make_symbol(const symbol_t sym); Pairs are created by using the cons and conc standard functions in the lisp interface: atom_t lisp_cons(const atom_t a, const atom_t b); atom_t lisp_conc(const atom_t a, const atom_t b); Both functions consume their arguments as those are often created for the sole purpose of being cons 'd or conc 'd. Deallocation Atom values must be manually deallocated using the X(...) macro defined in the slab interface. Atom values are reference counted, so great care must be taken when handling them. Registration The LISP_MODULE_SETUP macro is used to register a new module: #define LISP_MODULE_SETUP(__s, __n, ...) The first argument __s is the suffix of the function. The second argument __n is the name of the symbol. The variadic arguments represent the function argument symbols. For instance, the function add is defined as follow: static atom_t lisp_function_add(const lisp_t lisp, const atom_t closure) { /* ... */ } LISP_MODULE_SETUP(add, add, X, Y, NIL) Argument processing The argument symbols are defined as follows: C version Minima.l equivalent LISP_MODULE_SETUP(fun, fun) (def fun () ...) LISP_MODULE_SETUP(fun, fun, A) (def fun A ...) LISP_MODULE_SETUP(fun, fun, A, NIL) (def fun (A) ...) LISP_MODULE_SETUP(fun, fun, A, REM) (def fun (A . REM) ... ) LISP_MODULE_SETUP(fun, fun, A, B, NIL) (def fun (A B) ...) LISP_MODULE_SETUP(fun, fun, A, B, REM) (def fun (A B . REM) ...) Values for the declared symbols are passed to the module by the interpreter through the args parameter. They can be retrieved using the LISP_ARGS macro: #define LISP_ARGS(_c, _t, ...) The first argument is the closure passed to the function, which includes the arguments. The second argument is a name to use for the closure without the arguments. The remaining arguments are names of the arguments to pop.","title":"Modules"},{"location":"manual/Modules/#modules","text":"Modules are collections of function definitions. They are loaded using the load function. They can be implemented in in any language that compiles into shared libraries with a C interface (binary modules).","title":"Modules"},{"location":"manual/Modules/#binary-interface","text":"A module is a shared library that must export the following interface: const char * lisp_module_name(); atom_t lisp_module_setup(const lisp_t lisp); The lisp_module_setup function returns an atom_t value that points to a list definition as follows: (ARGUMENTS NIL . INTEGER) The integer part represents a pointer to a function with the following signature: atom_t lisp_function_NAME(const lisp_t lisp, const atom_t closure, const atom_t args);","title":"Binary interface"},{"location":"manual/Modules/#example","text":"Let's take the following code written for an add function and save it in a file called add.c : #include <mnml/lisp.h> #include <mnml/module.h> #include <mnml/slab.h> static atom_t lisp_function_add(const lisp_t lisp, const atom_t closure) { LISP_ARGS(closure, C, X, Y); /* * Make sure the arguments are numbers. */ if (!(IS_NUMB(x) && IS_NUMB(y))) { X(x, y); return UP(NIL); } /* * Return the new value. */ atom_t result = lisp_make_number(x->number + y->number); X(x, y); return result; } LISP_MODULE_SETUP(add, add, X, Y, NIL) Then, let's compile it: $ cc -I${PREFIX}/include -L${PREFIX}/lib -lminimal -o libminimal_function_add.${LD_EXT} add.c Where ${PREFIX} is Minima.l's installation prefix and ${LD_EXT} the linker extension for your platform ( .so on most, .dylib on Mac). Finally, place this shared object in your Minima.l cache ( $HOME/.mnml ) and fire the interpreter: : (load 'add) > add : (add 1 2) > 3","title":"Example"},{"location":"manual/Modules/#programming-interface","text":"","title":"Programming interface"},{"location":"manual/Modules/#atom-type","text":"The basic type in Minima.l is atom_t . This type represents numbers, characters, symbols, and pairs. Some symbols are defined as singletons, like NIL , TRUE , QUOTE , and WILDCARD .","title":"Atom type"},{"location":"manual/Modules/#allocation","text":"Atom values are allocated using functions in the maker interface: atom_t lisp_make_char(const char c); atom_t lisp_make_number(const int64_t num); atom_t lisp_make_string(const char * const s, const size_t len); atom_t lisp_make_symbol(const symbol_t sym); Pairs are created by using the cons and conc standard functions in the lisp interface: atom_t lisp_cons(const atom_t a, const atom_t b); atom_t lisp_conc(const atom_t a, const atom_t b); Both functions consume their arguments as those are often created for the sole purpose of being cons 'd or conc 'd.","title":"Allocation"},{"location":"manual/Modules/#deallocation","text":"Atom values must be manually deallocated using the X(...) macro defined in the slab interface. Atom values are reference counted, so great care must be taken when handling them.","title":"Deallocation"},{"location":"manual/Modules/#registration","text":"The LISP_MODULE_SETUP macro is used to register a new module: #define LISP_MODULE_SETUP(__s, __n, ...) The first argument __s is the suffix of the function. The second argument __n is the name of the symbol. The variadic arguments represent the function argument symbols. For instance, the function add is defined as follow: static atom_t lisp_function_add(const lisp_t lisp, const atom_t closure) { /* ... */ } LISP_MODULE_SETUP(add, add, X, Y, NIL)","title":"Registration"},{"location":"manual/Modules/#argument-processing","text":"The argument symbols are defined as follows: C version Minima.l equivalent LISP_MODULE_SETUP(fun, fun) (def fun () ...) LISP_MODULE_SETUP(fun, fun, A) (def fun A ...) LISP_MODULE_SETUP(fun, fun, A, NIL) (def fun (A) ...) LISP_MODULE_SETUP(fun, fun, A, REM) (def fun (A . REM) ... ) LISP_MODULE_SETUP(fun, fun, A, B, NIL) (def fun (A B) ...) LISP_MODULE_SETUP(fun, fun, A, B, REM) (def fun (A B . REM) ...) Values for the declared symbols are passed to the module by the interpreter through the args parameter. They can be retrieved using the LISP_ARGS macro: #define LISP_ARGS(_c, _t, ...) The first argument is the closure passed to the function, which includes the arguments. The second argument is a name to use for the closure without the arguments. The remaining arguments are names of the arguments to pop.","title":"Argument processing"},{"location":"manual/Reference/","text":"Reference Notation rules Elements in [] are optional A quoted symbol means that it is evaluated Summary Structural comparisons Name Syntax Module Description = (= 'any 'any) logic Equality <> (<> 'any 'any) logic Inequality Numeric comparison Name Syntax Module Description < (< 'num 'num) math Less-than <= (<= 'num 'num) math Less-than-or-equal-to > (> 'num 'num) math Greater-than > (>= 'num 'num) math Greater-than-or-equal-to Arithmetic operations Name Syntax Module Description + (+ 'num 'num) math Addition - (- 'num 'num) math Subtraction * (* 'num 'num) math Multiplication / (/ 'num 'num) math Division % (% 'num 'num) math Modulo Logical operations Name Syntax Module Description and (and 'any 'any) logic Logical AND not (not 'any) logic Logical NOT or (or 'any 'any) logic Logical OR Predicates Name Syntax Module Description chr? (chr? 'any) std Return T if any is a character lst? (lst? 'any) std Return T if any is a list nil? (nil? 'any) std Return T if any is NIL num? (num? 'any) std Return T if any is a number str? (str? 'any) std Return T if any is a string sym? (sym? 'any) std Return T if any is a symbol tru? (tru? 'any) std Return T if any is T String operations Name Syntax Module Description ntoa (ntoa 'num) Convert num into a string join (join 'lst 'chr) Join lst of strings into a chr -separted string split (split 'str 'chr) Split str of chr -separted tokens str (str 'sym) std Make a string out of sym trim (trim 'str) Trim str of leading and trailing white spaces Symbol definition Name Syntax Module Description def (def sym args [str] prg) std Define a function let (let lst . prg) std Let -binding symbols <- (setq sym 'any) std Update an existing symbol setq (setq sym 'any) std Bind a symbol sym (sym 'str) std Make a symbol out of str List manipulation Name Syntax Module Description append (append 'lst . any) Recursively append any to lst car (car 'lst) std Get the head element of lst cadr (cadr 'lst) manips Get the 2nd element of lst cddr (cddr 'lst) manips Get the tail of the tail of lst caddr (caddr 'lst) manips Get the 3rd element of lst cadddr (cadddr 'lst) manips Get the 4th element of lst caar (caar 'lst) manips Get the 1st element of the head of lst cadar (cadar 'lst) manips Get the 2nd element of the head of lst cdar (cdar 'lst) manips Get the tail of the head of lst cdr (cdr 'lst) std Get the tail of lst chr (chr 'num) std Get the character for ASCII numner num conc (conc 'lst 'lst) std Concatenate two lists into one cons (cons 'any 'any) std Construct a pair filter (filter 'fun 'lst) Filter lst using fun flatten (flatten 'lst) Flatten a nested lst foldl (foldl 'fun 'acc 'lst) Left-fold a lst foldr (foldr 'fun 'lst 'acc) Right-fold a lst insert (insert 'fun 'any 'lst) Insert any into a sorted lst using fun iter (iter 'fun 'lst) Iterate over the elements of a list last (last 'lst) Return the last element of a list len (len 'lst) std Compute the length lst list (list 'any ...) std Create a list with any map (map 'fun 'lst) Map the content of lst map2 (map2 'fun 'lst 'lst) Map the content of a two lists merge (merge 'fun 'fun 'lst 'lst) Sorted and deduped merge of two lists rev (rev 'lst) Reverse lst zip (zip 'lst 'lst) Sequentially pair-up elements from two lists Assoc-list operations Name Syntax Module Description assoc (assoc 'any 'lst) Query an association list erase (erase 'any 'lst) Remove an entry in an association list replc (replc 'any 'any 'lst) Replace an entry in an association list Control flow Name Syntax Module Description |> (|> any0 [any1] ...) std Fluent composition cond (cond 'any ...) std Predicate matching if (if 'any then [else]) std If construct match (match 'any ...) std Structural matching prog (prog any0 [any1] ...) std Sequential composition unless (unless 'any . prg) std Execute prg unless any is not NIL when (when 'any . prg) std Execute prg if any is not NIL while (while 'any . prg) std Execute prg while any is not NIL Input/output operations Name Syntax Module Description in (in 'any . prg) io In stream out (out 'any . prg) io Out stream prin (prin 'any ...) io Symbolic print of a list of any prinl (prinl 'any ...) io Symbolic print of a list of any , with new line print (print 'any ...) io Literal print of a list of any printl (printl 'any ...) io Literal print of a list of any , with new line read (read) io Read a token from the current input stream readline (readline) io Read one line from the current input stream Core operations Name Syntax Module Description eval (eval 'any) std Evaluate any load (load str) std Load an external asset time (time prg) sys Time the execution of prg quit (quit) std Quit the interpreter loop quote (quote . any) std Quote any Socket functions Name Syntax Module Description accept (accept 'num) unix Accept a connection from server descriptor num connect (connect 'dns 'svc) unix Connect to dns on service port svc listen (listen 'num) unix Listen for connections on port num System functions Name Syntax Module Description close (dup 'num) unix Close a file descriptor num dup (dup 'num ['num]) unix Duplicate a file descriptor num exec (exec 'str 'lst 'lst) unix Execute an image at path with arguments and environment fork (fork) unix Fork the current process run (run 'str 'lst 'alst) Run a external program str select (select 'fds 'rcb 'ecb) unix Wait for available data on descriptors fds unlink (unlink 'str) unix Unlink the file pointed by str wait (wait 'num) unix Wait for PID num Detailed description ASSOC Invocation (assoc 'any 'lst) Description Look-up any in the association list lst . Return value If a value is bound to any , return that value. If not, return NIL . Example : (assoc 'hello '((hello . world))) > world : (assoc 'foo '((hello . world))) > NIL CONC Invocation (conc 'lst1 'lst2) Description Destructively concatenate two lists lst1 and lst2 into a single list. Return value If lst1 is a list, return the concatenation of lst1 and lst2 . The value pointed by lst1 is actually modified. If lst1 is not a list, return NIL . Example : (setq A '(1 2)) > (1 2) : (conc A '(3 4)) > (1 2 3 4) : A > (1 2 3 4) COND Invocation (cond 'any (any . prg) (any . prg) ...) Description Evaluate any and use the car of the remaining arguments as a predicate over the result. Return the evaluation of the first positive match. The default or catch all case is written using the special value _ as car . Order is important. If multiple match exist, the first one is evaluated. If _ is placed before a valid match, _ is evaluated. Return value If a match is made, returns the evaluation of the corresponding prg . If no match is made, return NIL . Example : (def test (v) (cond v (num? . 'number) (lst? . 'list) (_ . 'unknown))) > test : (test 1) > number : (test '(1 2)) > list : (test T) > unknown CONS Invocation (cons 'any1 'any2) Description Construct a new list using the first argument for car and the second argument for cdr . Return value Return the newly constructed list without modifying the arguments. Example : (cons 1 2) > (1 . 2) : (cons 1 (cons 2 3)) > (1 2 . 3) DEF Invocation (def sym lst [str] prg ...) Description Define a function with arguments args and body prg and associate it with the symbol sym . An optional str can be specified as a documentation string and is ignored by the interpreter. Function defined with the def keyword are simply lambda functions assigned to symbol. The following expressions are equivalent: : (def add (a b) (+ a b)) > add : (setq add (\\ (a b) (+ a b))) > (\\ (a b) (+ a b)) Return value Return the S-expression of the newly defined function. Example : (def add (x y) (+ x y)) > ((x y) NIL NIL (+ x y)) EVAL Invocation (eval 'any) Description Evaluate any . Return value Return the result of the evaluation. Example : (eval (list '+ 1 1)) > 2 IF Invocation (if 'any . lst) Description When any evaluates to T , evaluate (car lst) . Otherwise, evaluate (car (cdr lst)) . Return value Return the result of the evaluation. Example : (def test (v) (if (> v 10) (* v 2))) > test : (test 5) > NIL : (test 20) > 40 IN Invocation (in 'any . prg) Description Create a new input channel context and evaluate prg within that context. The previous context is restored after the evaluation. When the first argument evaluates to NIL , the context uses stdin . When the argument evaluates to a string, in assumes the string contains a file path and tries to open that file. Return value Return the evaluation of prg . LET Invocation (let lst . prg) Description Evaluate prg within the context of the bind list lst . The bind list has the following format: ((any . 'any)(any . 'any)...) Return value Return the value of the evaluated prg . Example : (let ((lhv . (+ 1 2)) (rhv . (+ 3 4))) (+ lhv rhv)) > 10 LIST Invocation (list 'any ...) Description Create a list with any arguments. Return value Return the newly created list. Example : (list) > NIL : (list (+ 1 1) 3 \"a\") > (2 3 \"a\") LOAD Invocation (load 'str ...) (load '(mod sym ...)) (load 'sym ...) (load '(mod . T)) Description In the first form, load the lisp file pointed by str . If the path is prefixed by @lib , load will look for the file in the lib directory of the installation prefix. : (load \"@lib/cadr.l\") > ((x) NIL NIL (car (cdr x))) In the second form, load sym in the module mod . In the third and fourth forms, all symbols in the module mod are loaded. : (load '(math +)) > (+) Modules are searched in the lib/mnml directory of the installation prefix or in the MNML_MODULE_PATH environment variable. Return value In the first form, return the result of the last evaluated operation in the list. In the second and third form, return the list of loaded symbols. On error, NIL is returned. Example : (load \"lisp/cadr.l\") > ((x) NIL NIL (car (cdr x))) MATCH Invocation (match 'any (any . prg) ...) Description Evaluate any and use the car of the remaining arguments as a structural template for the result. The default or catch all case is written using the special value _ as car . Order is important. If multiple match exist, the first one is evaluated. If _ is placed before a valid match, _ is evaluated. Return value Return the evaluation of the first positive match. Return NIL otherwise. Example : (prinl (match '(1 2 3) ((1 _ _) . \"OK\") (_ . \"KO\"))) OK > (^O ^K) OUT Invocation (out 'any . prg) Description Create a new output channel context and evaluate prg within that context. The previous context is restored after the evaluation. When the first argument evaluates to NIL , the context uses stdout . When the argument evaluates to a string, out assumes the string contains a file path and tries to open that file. If the file does not exist, it is created. If the file exists, it is truncated. If the file path is prepended with a + the file must exist and data will be appended to it. Return value Return the evaluation of prg . Example : (out \"test.log\" (prinl \"Hello, world\")) > (^H ^e ^l ^l ^o ^, ^ ^w ^o ^r ^l ^d) PRIN Invocation (prin 'any ...) Description Print the string representation of any . When multiple arguments are printed, no separator is used. Return value Return the result of the evaluation of the last argument. If there is no argument, return NIL . Example : (prin \"hello, \" \"world!\") hello, world!> \"world!\" PRINL Invocation (prinl 'any ...) Description Calls prin and appends a new line. Return value Return the result of the evaluation of the last argument. If there is no argument, return NIL . Example : (prinl \"hello, \" \"world!\") hello, world! > \"world!\" PRINT Invocation (print 'any ...) Description Print the S-expression of any . When multiple arguments are printed, a space separator is used. Return value Return the result of the evaluation of the last argument. If there is no argument, return NIL . Example : (print 'a 'b '(1 2 3)) a b (1 2 3)> (1 2 3) PRINTL Invocation (printl 'any ...) Description Calls print and appends a new line. Return value Return the result of the evaluation of the last argument. If there is no argument, return NIL . Example : (print 'a 'b (1 2 3)) a b (1 2 3) > (1 2 3) PROG Invocation (prog prg1 prg2 ...) Description Evaluate prg1 , prg2 , ..., in sequence. Return value Return the the result of the last evaluation. Example : (prog (+ 1 1) (+ 2 2)) > 4 READ Invocation (read) Description Read a token from the current input stream. The current input stream differs depending on the context: When run interactively, the current input stream is stdin When executing a file, or as a shebang interpreter, the current input stream is that of the file The current input stream is also altered by the in command. Return value Return a valid token or NIL if the stream is closed or invalid. READLINE Invocation (readline) Description Read one line from the current input stream. Stop on EOF . Return value Return a line as a string trimmed of any carry return. NIL in case of EOF . RUN Invocation (run 'str 'lst 'alst) Description Run an external program at path str with arguments lst and environment alst . If alst is NIL , the current environment ENV is used instead. This function combines fork , exec , dup , close , pipe , and wait to provide a handy way to run external binaries in a single shot. Return value Return a pair with CAR as the status code of the binary and CDR the output of the command as list of lines. Example : (run \"/bin/hostname\" NIL NIL) > (0 (^E ^n ^c ^e ^l ^a ^d ^u ^s)) SET Invocation (<- 'sym 'any) Description Associate any with the symbol sym . The symbol must exist. Return value Return the previous value associated to the symbol. Example : (setq A (+ 1 2)) > 3 : (<- 'A 4) > 3 : A > 4 SETQ Invocation (setq sym 'any) Description Associate any with the symbol sym . Return value Return the value associated to the symbol. Example : (setq A (+ 1 2)) > 3 STREAM Invocation (|> any0 [any1] ...) Description Fluent composition operator. Evaluate any0 and pass the result to any1 , and so on until the end of the list. Return value Return the result of the last any operation. Example : (|> '(1 2 3) cdr car) > 2 TIME Invocation (time prg) Description Compute the execution time of prg . Return value Return the computed time, in nanoseconds. If prg is NIL , return the current timestamp. Example : (time (+ 1 2)) > 8433 : (time) 862596451378329","title":"Reference"},{"location":"manual/Reference/#reference","text":"","title":"Reference"},{"location":"manual/Reference/#notation-rules","text":"Elements in [] are optional A quoted symbol means that it is evaluated","title":"Notation rules"},{"location":"manual/Reference/#summary","text":"","title":"Summary"},{"location":"manual/Reference/#structural-comparisons","text":"Name Syntax Module Description = (= 'any 'any) logic Equality <> (<> 'any 'any) logic Inequality","title":"Structural comparisons"},{"location":"manual/Reference/#numeric-comparison","text":"Name Syntax Module Description < (< 'num 'num) math Less-than <= (<= 'num 'num) math Less-than-or-equal-to > (> 'num 'num) math Greater-than > (>= 'num 'num) math Greater-than-or-equal-to","title":"Numeric comparison"},{"location":"manual/Reference/#arithmetic-operations","text":"Name Syntax Module Description + (+ 'num 'num) math Addition - (- 'num 'num) math Subtraction * (* 'num 'num) math Multiplication / (/ 'num 'num) math Division % (% 'num 'num) math Modulo","title":"Arithmetic operations"},{"location":"manual/Reference/#logical-operations","text":"Name Syntax Module Description and (and 'any 'any) logic Logical AND not (not 'any) logic Logical NOT or (or 'any 'any) logic Logical OR","title":"Logical operations"},{"location":"manual/Reference/#predicates","text":"Name Syntax Module Description chr? (chr? 'any) std Return T if any is a character lst? (lst? 'any) std Return T if any is a list nil? (nil? 'any) std Return T if any is NIL num? (num? 'any) std Return T if any is a number str? (str? 'any) std Return T if any is a string sym? (sym? 'any) std Return T if any is a symbol tru? (tru? 'any) std Return T if any is T","title":"Predicates"},{"location":"manual/Reference/#string-operations","text":"Name Syntax Module Description ntoa (ntoa 'num) Convert num into a string join (join 'lst 'chr) Join lst of strings into a chr -separted string split (split 'str 'chr) Split str of chr -separted tokens str (str 'sym) std Make a string out of sym trim (trim 'str) Trim str of leading and trailing white spaces","title":"String operations"},{"location":"manual/Reference/#symbol-definition","text":"Name Syntax Module Description def (def sym args [str] prg) std Define a function let (let lst . prg) std Let -binding symbols <- (setq sym 'any) std Update an existing symbol setq (setq sym 'any) std Bind a symbol sym (sym 'str) std Make a symbol out of str","title":"Symbol definition"},{"location":"manual/Reference/#list-manipulation","text":"Name Syntax Module Description append (append 'lst . any) Recursively append any to lst car (car 'lst) std Get the head element of lst cadr (cadr 'lst) manips Get the 2nd element of lst cddr (cddr 'lst) manips Get the tail of the tail of lst caddr (caddr 'lst) manips Get the 3rd element of lst cadddr (cadddr 'lst) manips Get the 4th element of lst caar (caar 'lst) manips Get the 1st element of the head of lst cadar (cadar 'lst) manips Get the 2nd element of the head of lst cdar (cdar 'lst) manips Get the tail of the head of lst cdr (cdr 'lst) std Get the tail of lst chr (chr 'num) std Get the character for ASCII numner num conc (conc 'lst 'lst) std Concatenate two lists into one cons (cons 'any 'any) std Construct a pair filter (filter 'fun 'lst) Filter lst using fun flatten (flatten 'lst) Flatten a nested lst foldl (foldl 'fun 'acc 'lst) Left-fold a lst foldr (foldr 'fun 'lst 'acc) Right-fold a lst insert (insert 'fun 'any 'lst) Insert any into a sorted lst using fun iter (iter 'fun 'lst) Iterate over the elements of a list last (last 'lst) Return the last element of a list len (len 'lst) std Compute the length lst list (list 'any ...) std Create a list with any map (map 'fun 'lst) Map the content of lst map2 (map2 'fun 'lst 'lst) Map the content of a two lists merge (merge 'fun 'fun 'lst 'lst) Sorted and deduped merge of two lists rev (rev 'lst) Reverse lst zip (zip 'lst 'lst) Sequentially pair-up elements from two lists","title":"List manipulation"},{"location":"manual/Reference/#assoc-list-operations","text":"Name Syntax Module Description assoc (assoc 'any 'lst) Query an association list erase (erase 'any 'lst) Remove an entry in an association list replc (replc 'any 'any 'lst) Replace an entry in an association list","title":"Assoc-list operations"},{"location":"manual/Reference/#control-flow","text":"Name Syntax Module Description |> (|> any0 [any1] ...) std Fluent composition cond (cond 'any ...) std Predicate matching if (if 'any then [else]) std If construct match (match 'any ...) std Structural matching prog (prog any0 [any1] ...) std Sequential composition unless (unless 'any . prg) std Execute prg unless any is not NIL when (when 'any . prg) std Execute prg if any is not NIL while (while 'any . prg) std Execute prg while any is not NIL","title":"Control flow"},{"location":"manual/Reference/#inputoutput-operations","text":"Name Syntax Module Description in (in 'any . prg) io In stream out (out 'any . prg) io Out stream prin (prin 'any ...) io Symbolic print of a list of any prinl (prinl 'any ...) io Symbolic print of a list of any , with new line print (print 'any ...) io Literal print of a list of any printl (printl 'any ...) io Literal print of a list of any , with new line read (read) io Read a token from the current input stream readline (readline) io Read one line from the current input stream","title":"Input/output operations"},{"location":"manual/Reference/#core-operations","text":"Name Syntax Module Description eval (eval 'any) std Evaluate any load (load str) std Load an external asset time (time prg) sys Time the execution of prg quit (quit) std Quit the interpreter loop quote (quote . any) std Quote any","title":"Core operations"},{"location":"manual/Reference/#socket-functions","text":"Name Syntax Module Description accept (accept 'num) unix Accept a connection from server descriptor num connect (connect 'dns 'svc) unix Connect to dns on service port svc listen (listen 'num) unix Listen for connections on port num","title":"Socket functions"},{"location":"manual/Reference/#system-functions","text":"Name Syntax Module Description close (dup 'num) unix Close a file descriptor num dup (dup 'num ['num]) unix Duplicate a file descriptor num exec (exec 'str 'lst 'lst) unix Execute an image at path with arguments and environment fork (fork) unix Fork the current process run (run 'str 'lst 'alst) Run a external program str select (select 'fds 'rcb 'ecb) unix Wait for available data on descriptors fds unlink (unlink 'str) unix Unlink the file pointed by str wait (wait 'num) unix Wait for PID num","title":"System functions"},{"location":"manual/Reference/#detailed-description","text":"","title":"Detailed description"},{"location":"manual/Reference/#assoc","text":"","title":"ASSOC"},{"location":"manual/Reference/#invocation","text":"(assoc 'any 'lst)","title":"Invocation"},{"location":"manual/Reference/#description","text":"Look-up any in the association list lst .","title":"Description"},{"location":"manual/Reference/#return-value","text":"If a value is bound to any , return that value. If not, return NIL .","title":"Return value"},{"location":"manual/Reference/#example","text":": (assoc 'hello '((hello . world))) > world : (assoc 'foo '((hello . world))) > NIL","title":"Example"},{"location":"manual/Reference/#conc","text":"","title":"CONC"},{"location":"manual/Reference/#invocation_1","text":"(conc 'lst1 'lst2)","title":"Invocation"},{"location":"manual/Reference/#description_1","text":"Destructively concatenate two lists lst1 and lst2 into a single list.","title":"Description"},{"location":"manual/Reference/#return-value_1","text":"If lst1 is a list, return the concatenation of lst1 and lst2 . The value pointed by lst1 is actually modified. If lst1 is not a list, return NIL .","title":"Return value"},{"location":"manual/Reference/#example_1","text":": (setq A '(1 2)) > (1 2) : (conc A '(3 4)) > (1 2 3 4) : A > (1 2 3 4)","title":"Example"},{"location":"manual/Reference/#cond","text":"","title":"COND"},{"location":"manual/Reference/#invocation_2","text":"(cond 'any (any . prg) (any . prg) ...)","title":"Invocation"},{"location":"manual/Reference/#description_2","text":"Evaluate any and use the car of the remaining arguments as a predicate over the result. Return the evaluation of the first positive match. The default or catch all case is written using the special value _ as car . Order is important. If multiple match exist, the first one is evaluated. If _ is placed before a valid match, _ is evaluated.","title":"Description"},{"location":"manual/Reference/#return-value_2","text":"If a match is made, returns the evaluation of the corresponding prg . If no match is made, return NIL .","title":"Return value"},{"location":"manual/Reference/#example_2","text":": (def test (v) (cond v (num? . 'number) (lst? . 'list) (_ . 'unknown))) > test : (test 1) > number : (test '(1 2)) > list : (test T) > unknown","title":"Example"},{"location":"manual/Reference/#cons","text":"","title":"CONS"},{"location":"manual/Reference/#invocation_3","text":"(cons 'any1 'any2)","title":"Invocation"},{"location":"manual/Reference/#description_3","text":"Construct a new list using the first argument for car and the second argument for cdr .","title":"Description"},{"location":"manual/Reference/#return-value_3","text":"Return the newly constructed list without modifying the arguments.","title":"Return value"},{"location":"manual/Reference/#example_3","text":": (cons 1 2) > (1 . 2) : (cons 1 (cons 2 3)) > (1 2 . 3)","title":"Example"},{"location":"manual/Reference/#def","text":"","title":"DEF"},{"location":"manual/Reference/#invocation_4","text":"(def sym lst [str] prg ...)","title":"Invocation"},{"location":"manual/Reference/#description_4","text":"Define a function with arguments args and body prg and associate it with the symbol sym . An optional str can be specified as a documentation string and is ignored by the interpreter. Function defined with the def keyword are simply lambda functions assigned to symbol. The following expressions are equivalent: : (def add (a b) (+ a b)) > add : (setq add (\\ (a b) (+ a b))) > (\\ (a b) (+ a b))","title":"Description"},{"location":"manual/Reference/#return-value_4","text":"Return the S-expression of the newly defined function.","title":"Return value"},{"location":"manual/Reference/#example_4","text":": (def add (x y) (+ x y)) > ((x y) NIL NIL (+ x y))","title":"Example"},{"location":"manual/Reference/#eval","text":"","title":"EVAL"},{"location":"manual/Reference/#invocation_5","text":"(eval 'any)","title":"Invocation"},{"location":"manual/Reference/#description_5","text":"Evaluate any .","title":"Description"},{"location":"manual/Reference/#return-value_5","text":"Return the result of the evaluation.","title":"Return value"},{"location":"manual/Reference/#example_5","text":": (eval (list '+ 1 1)) > 2","title":"Example"},{"location":"manual/Reference/#if","text":"","title":"IF"},{"location":"manual/Reference/#invocation_6","text":"(if 'any . lst)","title":"Invocation"},{"location":"manual/Reference/#description_6","text":"When any evaluates to T , evaluate (car lst) . Otherwise, evaluate (car (cdr lst)) .","title":"Description"},{"location":"manual/Reference/#return-value_6","text":"Return the result of the evaluation.","title":"Return value"},{"location":"manual/Reference/#example_6","text":": (def test (v) (if (> v 10) (* v 2))) > test : (test 5) > NIL : (test 20) > 40","title":"Example"},{"location":"manual/Reference/#in","text":"","title":"IN"},{"location":"manual/Reference/#invocation_7","text":"(in 'any . prg)","title":"Invocation"},{"location":"manual/Reference/#description_7","text":"Create a new input channel context and evaluate prg within that context. The previous context is restored after the evaluation. When the first argument evaluates to NIL , the context uses stdin . When the argument evaluates to a string, in assumes the string contains a file path and tries to open that file.","title":"Description"},{"location":"manual/Reference/#return-value_7","text":"Return the evaluation of prg .","title":"Return value"},{"location":"manual/Reference/#let","text":"","title":"LET"},{"location":"manual/Reference/#invocation_8","text":"(let lst . prg)","title":"Invocation"},{"location":"manual/Reference/#description_8","text":"Evaluate prg within the context of the bind list lst . The bind list has the following format: ((any . 'any)(any . 'any)...)","title":"Description"},{"location":"manual/Reference/#return-value_8","text":"Return the value of the evaluated prg .","title":"Return value"},{"location":"manual/Reference/#example_7","text":": (let ((lhv . (+ 1 2)) (rhv . (+ 3 4))) (+ lhv rhv)) > 10","title":"Example"},{"location":"manual/Reference/#list","text":"","title":"LIST"},{"location":"manual/Reference/#invocation_9","text":"(list 'any ...)","title":"Invocation"},{"location":"manual/Reference/#description_9","text":"Create a list with any arguments.","title":"Description"},{"location":"manual/Reference/#return-value_9","text":"Return the newly created list.","title":"Return value"},{"location":"manual/Reference/#example_8","text":": (list) > NIL : (list (+ 1 1) 3 \"a\") > (2 3 \"a\")","title":"Example"},{"location":"manual/Reference/#load","text":"","title":"LOAD"},{"location":"manual/Reference/#invocation_10","text":"(load 'str ...) (load '(mod sym ...)) (load 'sym ...) (load '(mod . T))","title":"Invocation"},{"location":"manual/Reference/#description_10","text":"In the first form, load the lisp file pointed by str . If the path is prefixed by @lib , load will look for the file in the lib directory of the installation prefix. : (load \"@lib/cadr.l\") > ((x) NIL NIL (car (cdr x))) In the second form, load sym in the module mod . In the third and fourth forms, all symbols in the module mod are loaded. : (load '(math +)) > (+) Modules are searched in the lib/mnml directory of the installation prefix or in the MNML_MODULE_PATH environment variable.","title":"Description"},{"location":"manual/Reference/#return-value_10","text":"In the first form, return the result of the last evaluated operation in the list. In the second and third form, return the list of loaded symbols. On error, NIL is returned.","title":"Return value"},{"location":"manual/Reference/#example_9","text":": (load \"lisp/cadr.l\") > ((x) NIL NIL (car (cdr x)))","title":"Example"},{"location":"manual/Reference/#match","text":"","title":"MATCH"},{"location":"manual/Reference/#invocation_11","text":"(match 'any (any . prg) ...)","title":"Invocation"},{"location":"manual/Reference/#description_11","text":"Evaluate any and use the car of the remaining arguments as a structural template for the result. The default or catch all case is written using the special value _ as car . Order is important. If multiple match exist, the first one is evaluated. If _ is placed before a valid match, _ is evaluated.","title":"Description"},{"location":"manual/Reference/#return-value_11","text":"Return the evaluation of the first positive match. Return NIL otherwise.","title":"Return value"},{"location":"manual/Reference/#example_10","text":": (prinl (match '(1 2 3) ((1 _ _) . \"OK\") (_ . \"KO\"))) OK > (^O ^K)","title":"Example"},{"location":"manual/Reference/#out","text":"","title":"OUT"},{"location":"manual/Reference/#invocation_12","text":"(out 'any . prg)","title":"Invocation"},{"location":"manual/Reference/#description_12","text":"Create a new output channel context and evaluate prg within that context. The previous context is restored after the evaluation. When the first argument evaluates to NIL , the context uses stdout . When the argument evaluates to a string, out assumes the string contains a file path and tries to open that file. If the file does not exist, it is created. If the file exists, it is truncated. If the file path is prepended with a + the file must exist and data will be appended to it.","title":"Description"},{"location":"manual/Reference/#return-value_12","text":"Return the evaluation of prg .","title":"Return value"},{"location":"manual/Reference/#example_11","text":": (out \"test.log\" (prinl \"Hello, world\")) > (^H ^e ^l ^l ^o ^, ^ ^w ^o ^r ^l ^d)","title":"Example"},{"location":"manual/Reference/#prin","text":"","title":"PRIN"},{"location":"manual/Reference/#invocation_13","text":"(prin 'any ...)","title":"Invocation"},{"location":"manual/Reference/#description_13","text":"Print the string representation of any . When multiple arguments are printed, no separator is used.","title":"Description"},{"location":"manual/Reference/#return-value_13","text":"Return the result of the evaluation of the last argument. If there is no argument, return NIL .","title":"Return value"},{"location":"manual/Reference/#example_12","text":": (prin \"hello, \" \"world!\") hello, world!> \"world!\"","title":"Example"},{"location":"manual/Reference/#prinl","text":"","title":"PRINL"},{"location":"manual/Reference/#invocation_14","text":"(prinl 'any ...)","title":"Invocation"},{"location":"manual/Reference/#description_14","text":"Calls prin and appends a new line.","title":"Description"},{"location":"manual/Reference/#return-value_14","text":"Return the result of the evaluation of the last argument. If there is no argument, return NIL .","title":"Return value"},{"location":"manual/Reference/#example_13","text":": (prinl \"hello, \" \"world!\") hello, world! > \"world!\"","title":"Example"},{"location":"manual/Reference/#print","text":"","title":"PRINT"},{"location":"manual/Reference/#invocation_15","text":"(print 'any ...)","title":"Invocation"},{"location":"manual/Reference/#description_15","text":"Print the S-expression of any . When multiple arguments are printed, a space separator is used.","title":"Description"},{"location":"manual/Reference/#return-value_15","text":"Return the result of the evaluation of the last argument. If there is no argument, return NIL .","title":"Return value"},{"location":"manual/Reference/#example_14","text":": (print 'a 'b '(1 2 3)) a b (1 2 3)> (1 2 3)","title":"Example"},{"location":"manual/Reference/#printl","text":"","title":"PRINTL"},{"location":"manual/Reference/#invocation_16","text":"(printl 'any ...)","title":"Invocation"},{"location":"manual/Reference/#description_16","text":"Calls print and appends a new line.","title":"Description"},{"location":"manual/Reference/#return-value_16","text":"Return the result of the evaluation of the last argument. If there is no argument, return NIL .","title":"Return value"},{"location":"manual/Reference/#example_15","text":": (print 'a 'b (1 2 3)) a b (1 2 3) > (1 2 3)","title":"Example"},{"location":"manual/Reference/#prog","text":"","title":"PROG"},{"location":"manual/Reference/#invocation_17","text":"(prog prg1 prg2 ...)","title":"Invocation"},{"location":"manual/Reference/#description_17","text":"Evaluate prg1 , prg2 , ..., in sequence.","title":"Description"},{"location":"manual/Reference/#return-value_17","text":"Return the the result of the last evaluation.","title":"Return value"},{"location":"manual/Reference/#example_16","text":": (prog (+ 1 1) (+ 2 2)) > 4","title":"Example"},{"location":"manual/Reference/#read","text":"","title":"READ"},{"location":"manual/Reference/#invocation_18","text":"(read)","title":"Invocation"},{"location":"manual/Reference/#description_18","text":"Read a token from the current input stream. The current input stream differs depending on the context: When run interactively, the current input stream is stdin When executing a file, or as a shebang interpreter, the current input stream is that of the file The current input stream is also altered by the in command.","title":"Description"},{"location":"manual/Reference/#return-value_18","text":"Return a valid token or NIL if the stream is closed or invalid.","title":"Return value"},{"location":"manual/Reference/#readline","text":"","title":"READLINE"},{"location":"manual/Reference/#invocation_19","text":"(readline)","title":"Invocation"},{"location":"manual/Reference/#description_19","text":"Read one line from the current input stream. Stop on EOF .","title":"Description"},{"location":"manual/Reference/#return-value_19","text":"Return a line as a string trimmed of any carry return. NIL in case of EOF .","title":"Return value"},{"location":"manual/Reference/#run","text":"","title":"RUN"},{"location":"manual/Reference/#invocation_20","text":"(run 'str 'lst 'alst)","title":"Invocation"},{"location":"manual/Reference/#description_20","text":"Run an external program at path str with arguments lst and environment alst . If alst is NIL , the current environment ENV is used instead. This function combines fork , exec , dup , close , pipe , and wait to provide a handy way to run external binaries in a single shot.","title":"Description"},{"location":"manual/Reference/#return-value_20","text":"Return a pair with CAR as the status code of the binary and CDR the output of the command as list of lines.","title":"Return value"},{"location":"manual/Reference/#example_17","text":": (run \"/bin/hostname\" NIL NIL) > (0 (^E ^n ^c ^e ^l ^a ^d ^u ^s))","title":"Example"},{"location":"manual/Reference/#set","text":"","title":"SET"},{"location":"manual/Reference/#invocation_21","text":"(<- 'sym 'any)","title":"Invocation"},{"location":"manual/Reference/#description_21","text":"Associate any with the symbol sym . The symbol must exist.","title":"Description"},{"location":"manual/Reference/#return-value_21","text":"Return the previous value associated to the symbol.","title":"Return value"},{"location":"manual/Reference/#example_18","text":": (setq A (+ 1 2)) > 3 : (<- 'A 4) > 3 : A > 4","title":"Example"},{"location":"manual/Reference/#setq","text":"","title":"SETQ"},{"location":"manual/Reference/#invocation_22","text":"(setq sym 'any)","title":"Invocation"},{"location":"manual/Reference/#description_22","text":"Associate any with the symbol sym .","title":"Description"},{"location":"manual/Reference/#return-value_22","text":"Return the value associated to the symbol.","title":"Return value"},{"location":"manual/Reference/#example_19","text":": (setq A (+ 1 2)) > 3","title":"Example"},{"location":"manual/Reference/#stream","text":"","title":"STREAM"},{"location":"manual/Reference/#invocation_23","text":"(|> any0 [any1] ...)","title":"Invocation"},{"location":"manual/Reference/#description_23","text":"Fluent composition operator. Evaluate any0 and pass the result to any1 , and so on until the end of the list.","title":"Description"},{"location":"manual/Reference/#return-value_23","text":"Return the result of the last any operation.","title":"Return value"},{"location":"manual/Reference/#example_20","text":": (|> '(1 2 3) cdr car) > 2","title":"Example"},{"location":"manual/Reference/#time","text":"","title":"TIME"},{"location":"manual/Reference/#invocation_24","text":"(time prg)","title":"Invocation"},{"location":"manual/Reference/#description_24","text":"Compute the execution time of prg .","title":"Description"},{"location":"manual/Reference/#return-value_24","text":"Return the computed time, in nanoseconds. If prg is NIL , return the current timestamp.","title":"Return value"},{"location":"manual/Reference/#example_21","text":": (time (+ 1 2)) > 8433 : (time) 862596451378329","title":"Example"},{"location":"notes/Closures/","text":"Closures Minima.l implement lexical scope closures using stack-oriented association lists. These lists are created by symbol-binding operations and are carried over by functions and lambdas. Example Let's consider the following let operation: (let ((a . 1) (b . 2)) PRG) The closure made available to PRG is: (((a . 1) (b . 2))) Problem definition Symbol binding operations are operations that associate a value to a symbol. This association can either happen at the global scope or at the local scope. Operations that impact the global scope are def , setq and <- to the extent that it only alters existing symbols. Operations that impact the local scope are let and <- . The let operation actually creates a local scope and can be used to define lambdas as local functions: (let ((fn . (\\ (a b) (+ a b)))) (fn 1 2)) These local scopes can be nested, and so can be these local functions: (let ((fn0 . (\\ (a b) (+ a b)))) (let ((fn1 . (\\ (a b) (- b a)))) (fn1 (fn0 2 2) (fn0 1 1)))) Local functions need to be shielded from nesting operations that redefine symbols. For instance: (let ((a . 1) # Level 0 scope (fn0 . (\\ (x) (+ x a)))) # (let ((a . 2)) # Level 1 scope (fn0 3))) # This expression is expected to return the value 4 as symbol a was assigned the value 1 when the lambda was defined . To ensure that behavior, the lambda assigned to fn0 must save the closure available at its definition site . Closure stack The solution implemented in Minima.l to achieve this is a closure stack. At the bottom level of the stack is the global scope. Then, each nested local scope pushes its closure on the stack. When symbols are resolved, Minima.l crawls up the stack of closure to find the first match. The global scope is always checked at the last resort. When a function is defined at the global scope using def , its closure capture is empty. When a function is defined at the local scope using let and a lambda, the lambda function captures the closure into the generated function definition.","title":"Closures"},{"location":"notes/Closures/#closures","text":"Minima.l implement lexical scope closures using stack-oriented association lists. These lists are created by symbol-binding operations and are carried over by functions and lambdas.","title":"Closures"},{"location":"notes/Closures/#example","text":"Let's consider the following let operation: (let ((a . 1) (b . 2)) PRG) The closure made available to PRG is: (((a . 1) (b . 2)))","title":"Example"},{"location":"notes/Closures/#problem-definition","text":"Symbol binding operations are operations that associate a value to a symbol. This association can either happen at the global scope or at the local scope. Operations that impact the global scope are def , setq and <- to the extent that it only alters existing symbols. Operations that impact the local scope are let and <- . The let operation actually creates a local scope and can be used to define lambdas as local functions: (let ((fn . (\\ (a b) (+ a b)))) (fn 1 2)) These local scopes can be nested, and so can be these local functions: (let ((fn0 . (\\ (a b) (+ a b)))) (let ((fn1 . (\\ (a b) (- b a)))) (fn1 (fn0 2 2) (fn0 1 1)))) Local functions need to be shielded from nesting operations that redefine symbols. For instance: (let ((a . 1) # Level 0 scope (fn0 . (\\ (x) (+ x a)))) # (let ((a . 2)) # Level 1 scope (fn0 3))) # This expression is expected to return the value 4 as symbol a was assigned the value 1 when the lambda was defined . To ensure that behavior, the lambda assigned to fn0 must save the closure available at its definition site .","title":"Problem definition"},{"location":"notes/Closures/#closure-stack","text":"The solution implemented in Minima.l to achieve this is a closure stack. At the bottom level of the stack is the global scope. Then, each nested local scope pushes its closure on the stack. When symbols are resolved, Minima.l crawls up the stack of closure to find the first match. The global scope is always checked at the last resort. When a function is defined at the global scope using def , its closure capture is empty. When a function is defined at the local scope using let and a lambda, the lambda function captures the closure into the generated function definition.","title":"Closure stack"},{"location":"notes/Continuations/","text":"Continuations We use the greek letter \u03ba (0x03BA) to represent the current continuation. Principle Function with one arguments ; Normal style (not T) ; Continuation-passing style (define (notcps v \u03ba) (k (not v))) Function with two arguments ; Normal style (add 1 2) ; Continuation-passing style (define (add a b \u03ba) (\u03ba (+ a b))) Singly-nested functions ; Normal style (define (fn) (add (mul 1 2) 3) ; Continuation-passing style (define (add a b \u03ba) (k (+ a b))) (define (mul a b \u03ba) (k (* a b))) (define (fn \u03ba) (mul 1 2 (lambda (x) (add x 3 \u03ba))) Doubly-nested functions ; Normal style (define (fn) (add (mul 1 2) (div 3 4))) ; Continuation-passing style (define (add a b \u03ba) (k (+ a b))) (define (mul a b \u03ba) (k (* a b))) (define (div a b \u03ba) (k (/ a b))) (define (fn \u03ba) (mul 1 2 (lambda (x) (div 4 2 (lambda (y) (add x y \u03ba)))))) Control structures If-Then-Else ; Normal style (define (fn v) (if (equ v 0) (add v 1) (sub v 1))) ; Continuation-passing style (define (fn v \u03ba) (equ v 0 (lambda (x) (if x (add v 1 \u03ba) (sub v 1 \u03ba))) Evaluation The continuation-passing style represent a function call as a chain of continuation-accepting functions f(..., \u03ba) where the function of rank N-1 is used as the continuation of the function of rank N . Function with two arguments Step Description 1 Apply current continuation to the result 2 Lift the second argument 2 Lift the first argument Tree view (define (fn \u03ba) (mul 1 ; immediate 2 ; immediate (kappa (x) (div ;.......................................................< continuation_2 4 ; immediate | 2 ; immediate | (kappa (y) (add ;....................< continuation_1 | x ; closure variable | | y ; argument variable | | \u03ba ; closure variable | | ))) | | )) | )) ABI view Types struct _continuation_t; typedef union _value_t { int64_t integer; char * string; void (*continuation)(union _value_t * environment, union _value_t result); } value_t; typedef value_t environment_t[16]; typedef void (*continuation_t)(environment_t environment, value_t result); Basic functions void fn_add(environment_t E, value_t A0, value_t A1, continuation_t K) { const register value_t result = { .integer = A0.integer + A1.integer }; K(E, result); } void fn_mul(environment_t E, value_t A0, value_t A1, continuation_t K) { const register value_t result = { .integer = A0.integer * A1.integer }; K(E, result); } void fn_div(environment_t E, value_t A0, value_t A1, continuation_t K) { const register value_t result = { .integer = A0.integer / A1.integer }; K(E, result); } Continuations void cont_1(environment_t E, value_t Y) { fn_add(E, E[1], Y, E[0].continuation); } void cont_2(environment_t E, value_t X) { register const value_t A0 = { .integer = 4 }; register const value_t A1 = { .integer = 2 }; E[1] = X; fn_div(E, A0, A1, cont_1); } void print(environment_t E, value_t X) { printf(\"Hello %lld\\n\", X.integer); } Top and main void fn(environment_t E, continuation_t K) { register const value_t A0 = { .integer = 1 }; register const value_t A1 = { .integer = 2 }; E[0].continuation = K; fn_mul(E, A0, A1, cont_2); } int main(const int argc, char ** const argv) { /* * Create an empty environment. */ environment_t env; memset(env, 0, sizeof(env)); /* * Call the function. */ fn(env, print); return 0; }","title":"Continuations"},{"location":"notes/Continuations/#continuations","text":"We use the greek letter \u03ba (0x03BA) to represent the current continuation.","title":"Continuations"},{"location":"notes/Continuations/#principle","text":"","title":"Principle"},{"location":"notes/Continuations/#function-with-one-arguments","text":"; Normal style (not T) ; Continuation-passing style (define (notcps v \u03ba) (k (not v)))","title":"Function with one arguments"},{"location":"notes/Continuations/#function-with-two-arguments","text":"; Normal style (add 1 2) ; Continuation-passing style (define (add a b \u03ba) (\u03ba (+ a b)))","title":"Function with two arguments"},{"location":"notes/Continuations/#singly-nested-functions","text":"; Normal style (define (fn) (add (mul 1 2) 3) ; Continuation-passing style (define (add a b \u03ba) (k (+ a b))) (define (mul a b \u03ba) (k (* a b))) (define (fn \u03ba) (mul 1 2 (lambda (x) (add x 3 \u03ba)))","title":"Singly-nested functions"},{"location":"notes/Continuations/#doubly-nested-functions","text":"; Normal style (define (fn) (add (mul 1 2) (div 3 4))) ; Continuation-passing style (define (add a b \u03ba) (k (+ a b))) (define (mul a b \u03ba) (k (* a b))) (define (div a b \u03ba) (k (/ a b))) (define (fn \u03ba) (mul 1 2 (lambda (x) (div 4 2 (lambda (y) (add x y \u03ba))))))","title":"Doubly-nested functions"},{"location":"notes/Continuations/#control-structures","text":"","title":"Control structures"},{"location":"notes/Continuations/#if-then-else","text":"; Normal style (define (fn v) (if (equ v 0) (add v 1) (sub v 1))) ; Continuation-passing style (define (fn v \u03ba) (equ v 0 (lambda (x) (if x (add v 1 \u03ba) (sub v 1 \u03ba)))","title":"If-Then-Else"},{"location":"notes/Continuations/#evaluation","text":"The continuation-passing style represent a function call as a chain of continuation-accepting functions f(..., \u03ba) where the function of rank N-1 is used as the continuation of the function of rank N .","title":"Evaluation"},{"location":"notes/Continuations/#function-with-two-arguments_1","text":"Step Description 1 Apply current continuation to the result 2 Lift the second argument 2 Lift the first argument","title":"Function with two arguments"},{"location":"notes/Continuations/#tree-view","text":"(define (fn \u03ba) (mul 1 ; immediate 2 ; immediate (kappa (x) (div ;.......................................................< continuation_2 4 ; immediate | 2 ; immediate | (kappa (y) (add ;....................< continuation_1 | x ; closure variable | | y ; argument variable | | \u03ba ; closure variable | | ))) | | )) | ))","title":"Tree view"},{"location":"notes/Continuations/#abi-view","text":"","title":"ABI view"},{"location":"notes/Continuations/#types","text":"struct _continuation_t; typedef union _value_t { int64_t integer; char * string; void (*continuation)(union _value_t * environment, union _value_t result); } value_t; typedef value_t environment_t[16]; typedef void (*continuation_t)(environment_t environment, value_t result);","title":"Types"},{"location":"notes/Continuations/#basic-functions","text":"void fn_add(environment_t E, value_t A0, value_t A1, continuation_t K) { const register value_t result = { .integer = A0.integer + A1.integer }; K(E, result); } void fn_mul(environment_t E, value_t A0, value_t A1, continuation_t K) { const register value_t result = { .integer = A0.integer * A1.integer }; K(E, result); } void fn_div(environment_t E, value_t A0, value_t A1, continuation_t K) { const register value_t result = { .integer = A0.integer / A1.integer }; K(E, result); }","title":"Basic functions"},{"location":"notes/Continuations/#continuations_1","text":"void cont_1(environment_t E, value_t Y) { fn_add(E, E[1], Y, E[0].continuation); } void cont_2(environment_t E, value_t X) { register const value_t A0 = { .integer = 4 }; register const value_t A1 = { .integer = 2 }; E[1] = X; fn_div(E, A0, A1, cont_1); } void print(environment_t E, value_t X) { printf(\"Hello %lld\\n\", X.integer); }","title":"Continuations"},{"location":"notes/Continuations/#top-and-main","text":"void fn(environment_t E, continuation_t K) { register const value_t A0 = { .integer = 1 }; register const value_t A1 = { .integer = 2 }; E[0].continuation = K; fn_mul(E, A0, A1, cont_2); } int main(const int argc, char ** const argv) { /* * Create an empty environment. */ environment_t env; memset(env, 0, sizeof(env)); /* * Call the function. */ fn(env, print); return 0; }","title":"Top and main"},{"location":"notes/Inference/","text":"Type inference On control A missing else branch is not an error. It should be forwarded to the next continuation. How should that be forwarded? As an atom pointing to NIL ? Do all continuation need to check for NIL then? Or should we simply disallow if -only control? Why not use atoms? We don't use atom_t for performance reason as we don't want to hit the slab allocator for every new value. That choice deprives us from a type annotation. Optionals The default return type is really T | NIL , not simply T . In that case, what we are really handling are T optional . How do I efficiently implement optional in C? Should I use another register in the value_t definition to embed whether the value is present or not? This solution would not optimize well. typedef struct _value { bool present; union { int64_t number; atom_t atom; atom_t (*callback)(struct _closure * C, struct _value V); }; } value_t; Forbid undefined scenarios Another solution would be to simply forbid that case since C forbids it. That allows us keep using simple types. Decision We will forbid undefined scenarios.","title":"Type Inference"},{"location":"notes/Inference/#type-inference","text":"","title":"Type inference"},{"location":"notes/Inference/#on-control","text":"A missing else branch is not an error. It should be forwarded to the next continuation. How should that be forwarded? As an atom pointing to NIL ? Do all continuation need to check for NIL then? Or should we simply disallow if -only control?","title":"On control"},{"location":"notes/Inference/#why-not-use-atoms","text":"We don't use atom_t for performance reason as we don't want to hit the slab allocator for every new value. That choice deprives us from a type annotation.","title":"Why not use atoms?"},{"location":"notes/Inference/#optionals","text":"The default return type is really T | NIL , not simply T . In that case, what we are really handling are T optional . How do I efficiently implement optional in C? Should I use another register in the value_t definition to embed whether the value is present or not? This solution would not optimize well. typedef struct _value { bool present; union { int64_t number; atom_t atom; atom_t (*callback)(struct _closure * C, struct _value V); }; } value_t;","title":"Optionals"},{"location":"notes/Inference/#forbid-undefined-scenarios","text":"Another solution would be to simply forbid that case since C forbids it. That allows us keep using simple types.","title":"Forbid undefined scenarios"},{"location":"notes/Inference/#decision","text":"We will forbid undefined scenarios.","title":"Decision"}]}